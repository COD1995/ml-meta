Of course. I will populate the main template with the content for Chapter 7.

I have processed the text, cleaning up formatting, structuring the content with appropriate headings, converting all linear programs and mathematical notations to LaTeX, and creating placeholders for all figures.

Here is the complete HTML file for Chapter 7.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 7 ‚Äî Linear Programming and Reductions</title>

    <link rel="stylesheet" href="../../../assets/css/base.css" />
    <link rel="stylesheet" href="../../../assets/css/inline-styles.css" />
    <link rel="stylesheet" href="../../../assets/css/chapters.css" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"
    />

    <script src="../../../assets/js/mathjax-config.js"></script>

    <script
      defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"
    ></script>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.8.0/dist/highlightjs-line-numbers.min.js"
    ></script>
  </head>

  <body>
    <div id="reading-progress">
      <div id="reading-progress-bar"></div>
    </div>

    <nav class="side-nav">
      <div class="side-nav-controls">
        <button
          id="homeBtn"
          class="btn-toggle"
          aria-label="Home"
          onclick="location.href='../../../index.html'"
        >
          üè†
        </button>
        <span class="nav-divider"></span>
        <button
          id="themeToggle"
          class="btn-toggle"
          aria-label="Toggle dark mode"
        >
          üåì
        </button>
      </div>

      <hr class="side-nav-divider" />

      <div id="bookNav"></div>

      <hr class="side-nav-divider" />

      <div class="coffee-banner">
        <a
          href="https://buymeacoffee.com/guoj1995"
          id="coffeeButton"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Support ML-Meta on Buy Me a Coffee"
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M20 3H4V5H20V3Z" fill="currentColor" />
            <path
              d="M20 7H4C2.9 7 2 7.9 2 9V17C2 18.1 2.9 19 4 19H10C11.1 19 12 18.1 12 17V16H16C18.2 16 20 14.2 20 12V9C20 7.9 19.1 7 18 7H20Z"
              fill="currentColor"
            />
          </svg>
          <span>Support Us</span>
        </a>
      </div>

      <div class="slack-banner">
        <a
          href="https://join.slack.com/t/mlmetacommunity/shared_invite/zt-38mj0hx5v-8GyxvZ7lanC9HbywfUOwJw"
          id="slackButton"
          target="_blank"
          rel="noopener"
          aria-label="Join our Slack Community"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 122.8 122.8"
            fill="#fff"
            style="width: 1.5em; height: 1.5em; vertical-align: middle"
          >
            <path d="M30.3 78.6c0 5-4 9-9 9s-9-4-9-9 4-9 9-9h9v9z" />
            <path
              d="M34.8 78.6c0-5 4-9 9-9s9 4 9 9v22.5c0 5-4 9-9 9s-9-4-9-9V78.6z"
            />
            <path d="M44 30.3c-5 0-9-4-9-9s4-9 9-9 9 4 9 9v9H44z" />
            <path
              d="M44 34.8c5 0 9 4 9 9s-4 9-9 9H21.5c-5 0-9-4-9-9s4-9 9-9H44z"
            />
            <path d="M92.5 44c0-5 4-9 9-9s9 4 9 9-4 9-9 9h-9V44z" />
            <path
              d="M88 44c0 5-4 9-9 9s-9-4-9-9V21.5c0-5 4-9 9-9s9 4 9 9V44z"
            />
            <path d="M78.8 92.5c5 0 9 4 9 9s-4 9-9 9-9-4-9-9v-9h9z" />
            <path
              d="M78.8 88c-5 0-9-4-9-9s4-9 9-9h22.5c5 0 9 4 9 9s-4 9-9 9H78.8z"
            />
          </svg>
          <span style="margin-left: 0.5em; vertical-align: middle"
            >Join our Slack</span
          >
        </a>
      </div>
    </nav>
    <div class="container content">
      <h1>Chapter 7: Linear Programming and Reductions</h1>
      <p>
        Many of the problems for which we want algorithms are optimization
        tasks: the shortest path, the cheapest spanning tree, the longest
        increasing subsequence, and so on. In such cases, we seek a solution
        that (1) satisfies certain constraints (for instance, the path must use
        edges of the graph and lead from s to t, the tree must touch all nodes,
        the subsequence must be increasing); and (2) is the best possible, with
        respect to some well-defined criterion, among all solutions that
        satisfy these constraints.
      </p>
      <p>
        <strong>Linear programming</strong> describes a broad class of optimization tasks in
        which both the constraints and the optimization criterion are linear
        functions. It turns out an enormous number of problems can be expressed
        in this way.
      </p>

      <section id="intro-lp">
        <h2>7.1 An introduction to linear programming</h2>
        <p>
          In a linear programming problem we are given a set of variables, and
          we want to assign real values to them so as to (1) satisfy a set of
          linear equations and/or linear inequalities involving these variables
          and (2) maximize or minimize a given linear objective function.
        </p>

        <h3>7.1.1 Example: profit maximization</h3>
        <p>
          A boutique chocolatier has two products: Pyramide and Pyramide Nuit.
          How much of each should it produce to maximize profits? Let's say it
          makes $x_1$ boxes of Pyramide per day, at a profit of $1 each, and
          $x_2$ boxes of Nuit, at a profit of $6 apiece. The constraints are:
          demand is limited to 200 boxes of Pyramide and 300 of Nuit, and the
          workforce can produce at most 400 boxes total per day.
        </p>
        <blockquote class="code-block">
            <strong>Objective function:</strong> max $x_1 + 6x_2$<br/>
            <strong>Constraints:</strong>
            <pre>
$x_1 \le 200$
$x_2 \le 300$
$x_1 + x_2 \le 400$
$x_1, x_2 \ge 0$</pre>
        </blockquote>
        <p>
          The set of all feasible solutions is a convex polygon (Figure 7.1).
          The objective function is a line that we move as far as possible while
          still touching the feasible region. The optimum solution will
          therefore be a vertex of the polygon.
        </p>
        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-1.png"
            alt="The feasible region and objective function for a linear program."
            width="700"
          />
          <figcaption>
            Figure 7.1 (a) The feasible region for a linear program. (b)
            Contour lines of the objective function.
          </figcaption>
        </figure>
        <p>
            It is a general rule of linear programs that the optimum is achieved at a vertex of the feasible region.
        </p>
        <h4>Solving linear programs</h4>
        <p>
            Linear programs (LPs) can be solved by the <strong>simplex method</strong>, which starts at a vertex and repeatedly moves to an adjacent vertex of better objective value. Upon reaching a vertex that has no better neighbor, simplex declares it to be optimal and halts.
        </p>

        <h4>More products</h4>
        <p>
            If the chocolatier adds a third product, Pyramide Luxe, at a profit of $13 per box ($x_3$), with additional constraints, the problem becomes three-dimensional. The feasible region is now a polyhedron. The objective function $x_1 + 6x_2 + 13x_3 = c$ is a plane. The simplex algorithm behaves similarly, moving from vertex to vertex along the edges of the polyhedron, steadily increasing profit.
        </p>
        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-2.png"
            alt="The feasible polyhedron for a 3-variable LP."
            width="500"
          />
          <figcaption>
            Figure 7.2 The feasible polyhedron for a three-variable linear program.
          </figcaption>
        </figure>

        <h3>7.1.2 Example: production planning</h3>
        <p>
            A company making handwoven carpets has seasonal demand ($d_1, \dots, d_{12}$). It can handle fluctuations by using overtime, hiring/firing workers, or storing surplus carpets, all of which have associated costs. This complex problem can be formulated as an LP to minimize total cost. The variables would include workers per month ($w_i$), carpets made ($x_i$), overtime production ($o_i$), workers hired/fired ($h_i, f_i$), and carpets stored ($s_i$). The constraints would define the relationships between these variables, and the objective function would be the total cost to be minimized.
        </p>

        <h3>7.1.3 Example: optimum bandwidth allocation</h3>
        <p>
            A network service provider needs to establish three connections (A-B, B-C, A-C), each with a certain payment per unit of bandwidth. Each connection can be routed along a short or long path. The goal is to route the connections to maximize revenue without exceeding the bandwidth capacity of any network line. This can be formulated as an LP with variables for the bandwidth on each path of each connection.
        </p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-3.png"
              alt="A communications network with bandwidths shown."
              width="500"
            />
            <figcaption>
              Figure 7.3 A communications network between three users A, B, and C.
            </figcaption>
          </figure>

        <h3>Reductions</h3>
        <p>
            Many computational problems can be reduced to one another. If a problem P can be solved using a subroutine for problem Q, we say P reduces to Q. This is a powerful concept because an efficient algorithm for Q can then be used to solve P and many other problems. Linear programming is a prime example of a problem to which a vast number of other problems reduce.
        </p>

        <h3>7.1.4 Variants of linear programming</h3>
        <p>
            Any LP can be transformed into a **standard form** (e.g., minimization, all constraints are equations, all variables are non-negative) through simple conversions:
        </p>
        <ul>
            <li>Maximization can be turned into minimization by multiplying the objective function by -1.</li>
            <li>An inequality $\sum a_i x_i \le b$ can be converted to an equation $\sum a_i x_i + s = b$ by adding a non-negative **slack variable** $s$.</li>
            <li>An equation $ax=b$ can be replaced by two inequalities, $ax \le b$ and $ax \ge b$.</li>
            <li>An unrestricted variable $x$ can be replaced by the difference of two non-negative variables, $x^+ - x^-$.</li>
        </ul>
        <p>Using matrix-vector notation, a typical LP can be expressed concisely:</p>
        <blockquote class="code-block">
            max $c^T x$<br/>
            $Ax \le b$<br/>
            $x \ge 0$
        </blockquote>
      </section>
      
      <hr/>

      <section id="network-flows">
        <h2>7.2 Flows in networks</h2>
        <p>The problem of shipping the maximum possible amount of a commodity from a source $s$ to a sink $t$ in a network is a classic LP problem. Each edge in the network has a maximum capacity.</p>
        <p>A **flow** assigns a value $f_e$ to each edge $e$ satisfying two properties:</p>
        <ol>
            <li><strong>Capacity constraints:</strong> $0 \le f_e \le c_e$ for all edges $e$.</li>
            <li><strong>Flow conservation:</strong> For all nodes $u$ (except $s$ and $t$), the flow entering $u$ equals the flow leaving $u$.</li>
        </ol>
        <p>The goal is to maximize the total flow leaving the source $s$. This can be directly translated into an LP. The simplex algorithm, when applied to this problem, finds an s-t path in a "residual network" and pushes as much flow as possible along it. This is repeated until no such path can be found.</p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-4.png"
              alt="A network with edge capacities and a flow."
              width="700"
            />
            <figcaption>
              Figure 7.4 (a) A network with edge capacities. (b) A flow in the network.
            </figcaption>
        </figure>
        <p>
            A remarkable result, the **max-flow min-cut theorem**, states that the size of the maximum flow in a network is equal to the capacity of the minimum cut (the smallest total capacity of edges that, if removed, would disconnect $s$ from $t$).
        </p>
      </section>

      <hr/>

      <section id="bipartite-matching">
        <h2>7.3 Bipartite matching</h2>
        <p>
            The problem of finding a **perfect matching** in a bipartite graph (e.g., pairing boys and girls who like each other) can be reduced to the maximum-flow problem.
        </p>
        <p>
            We create a source $s$ with edges to all boys, and a sink $t$ with edges from all girls. All edges in the original graph are directed from boy to girl. By setting all edge capacities to 1, a max flow of size equal to the number of boys corresponds to a perfect matching. A key property here is that for integer capacities, the max-flow algorithm finds an optimal flow with integer values, which correctly corresponds to a valid matching.
        </p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-8.png"
              alt="A matchmaking network for bipartite matching."
              width="600"
            />
            <figcaption>
              Figure 7.8 A matchmaking network. Each edge has a capacity of one.
            </figcaption>
          </figure>
      </section>

      <hr/>

      <section id="duality">
        <h2>7.4 Duality</h2>
        <p>
            Every linear maximization program (the **primal**) has a corresponding minimization program (the **dual**). Any feasible solution to the dual provides an upper bound on the optimal value of the primal. The **duality theorem** states that if an LP has a bounded optimum, then so does its dual, and their optimal values are equal.
        </p>
        <p>
            This provides a powerful way to certify optimality. If you find a feasible solution for the primal and a feasible solution for the dual that have the same objective value, you know both must be optimal. The relationship between max-flow and min-cut is a special case of LP duality.
        </p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-10.png"
              alt="A primal LP and its corresponding dual LP."
              width="700"
            />
            <figcaption>
              Figure 7.10 A generic primal LP in matrix-vector form, and its dual.
            </figcaption>
          </figure>
      </section>

      <hr/>

      <section id="simplex-algorithm">
        <h2>7.6 The simplex algorithm</h2>
        <p>
            The simplex algorithm solves LPs by moving from vertex to vertex on the surface of the n-dimensional feasible polyhedron.
        </p>
        <p>
            At each vertex, it performs two tasks:
        </p>
        <ol>
            <li>Checks if the current vertex is optimal. This is easy if the vertex is at the origin: it's optimal if and only if all coefficients in the objective function are non-positive.</li>
            <li>Determines where to move next. If not optimal, it moves along an edge (by increasing a variable with a positive objective coefficient) to a neighboring vertex with a better objective value.</li>
        </ol>
        <p>
            If a vertex is not at the origin, the algorithm cleverly transforms the coordinate system to move the current vertex to the origin, then solves the problem in this new "local" view. While simplex is very efficient in practice, its worst-case running time is exponential. Other algorithms, like the ellipsoid and interior-point methods, are provably polynomial-time.
        </p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_7_imgs/figure-7-13.png"
              alt="An example of the Simplex algorithm in action."
              width="700"
            />
            <figcaption>
              Figure 7.13 Simplex in action.
            </figcaption>
          </figure>
      </section>

      <section id="comments">
        <script
          src="https://utteranc.es/client.js"
          repo="COD1995/ml-meta"
          issue-term="pathname"
          label="comment"
          theme="github-light"
          crossorigin="anonymous"
          async
        ></script>
      </section>

      <footer>
        <p>
          ¬© 2025 Kristopher Kodweis ‚Ä¢
          <a
            href="https://github.com/COD1995/ml-meta"
            target="_blank"
            rel="noopener"
          >
            View on GitHub
          </a>
        </p>
      </footer>
    </div>

    <script type="module" src="../../../assets/js/main.js"></script>
    <script type="module" src="../../../assets/js/chapter-page.js"></script>

    <script src="book-data.js"></script>

    <script type="module" src="../../../assets/js/build-side-nav.js"></script>
  </body>
</html>
```