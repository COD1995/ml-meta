<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 4 ‚Äî Paths in Graphs</title>

    <link rel="stylesheet" href="../../../assets/css/base.css" />
    <link rel="stylesheet" href="../../../assets/css/inline-styles.css" />
    <link rel="stylesheet" href="../../../assets/css/chapters.css" />

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"
    />

    <script src="../../../assets/js/mathjax-config.js"></script>

    <script
      defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"
    ></script>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.8.0/dist/highlightjs-line-numbers.min.js"
    ></script>
  </head>

  <body>
    <div id="reading-progress">
      <div id="reading-progress-bar"></div>
    </div>

    <nav class="side-nav">
      <div class="side-nav-controls">
        <button
          id="homeBtn"
          class="btn-toggle"
          aria-label="Home"
          onclick="location.href='../../../index.html'"
        >
          üè†
        </button>
        <span class="nav-divider"></span>
        <button
          id="themeToggle"
          class="btn-toggle"
          aria-label="Toggle dark mode"
        >
          üåì
        </button>
      </div>

      <hr class="side-nav-divider" />

      <div id="bookNav"></div>

      <hr class="side-nav-divider" />

      <div class="coffee-banner">
        <a
          href="https://buymeacoffee.com/guoj1995"
          id="coffeeButton"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Support ML-Meta on Buy Me a Coffee"
        >
          <svg
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path d="M20 3H4V5H20V3Z" fill="currentColor" />
            <path
              d="M20 7H4C2.9 7 2 7.9 2 9V17C2 18.1 2.9 19 4 19H10C11.1 19 12 18.1 12 17V16H16C18.2 16 20 14.2 20 12V9C20 7.9 19.1 7 18 7H20Z"
              fill="currentColor"
            />
          </svg>
          <span>Support Us</span>
        </a>
      </div>

      <div class="slack-banner">
        <a
          href="https://join.slack.com/t/mlmetacommunity/shared_invite/zt-38mj0hx5v-8GyxvZ7lanC9HbywfUOwJw"
          id="slackButton"
          target="_blank"
          rel="noopener"
          aria-label="Join our Slack Community"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 122.8 122.8"
            fill="#fff"
            style="width: 1.5em; height: 1.5em; vertical-align: middle"
          >
            <path d="M30.3 78.6c0 5-4 9-9 9s-9-4-9-9 4-9 9-9h9v9z" />
            <path
              d="M34.8 78.6c0-5 4-9 9-9s9 4 9 9v22.5c0 5-4 9-9 9s-9-4-9-9V78.6z"
            />
            <path d="M44 30.3c-5 0-9-4-9-9s4-9 9-9 9 4 9 9v9H44z"
            />
            <path
              d="M44 34.8c5 0 9 4 9 9s-4 9-9 9H21.5c-5 0-9-4-9-9s4-9 9-9H44z"
            />
            <path d="M92.5 44c0-5 4-9 9-9s9 4 9 9-4 9-9 9h-9V44z" />
            <path
              d="M88 44c0 5-4 9-9 9s-9-4-9-9V21.5c0-5 4-9 9-9s9 4 9 9V44z"
            />
            <path d="M78.8 92.5c5 0 9 4 9 9s-4 9-9 9-9-4-9-9v-9h9z" />
            <path
              d="M78.8 88c-5 0-9-4-9-9s4-9 9-9h22.5c5 0 9 4 9 9s-4 9-9 9H78.8z"
            />
          </svg>
          <span style="margin-left: 0.5em; vertical-align: middle"
            >Join our Slack</span
          >
        </a>
      </div>
    </nav>
    <div class="container content">
      <h1>Chapter 4: Paths in Graphs</h1>

      <section id="distances">
        <h2>4.1 Distances</h2>
        <p>
          Depth-first search readily identifies all the vertices of a graph that
          can be reached from a designated starting point. It also finds
          explicit paths to these vertices, summarized in its search tree
          (Figure 4.1). However, these paths might not be the most economical
          ones possible. In the figure, vertex C is reachable from S by
          traversing just one edge, while the DFS tree shows a path of length 3.
          This chapter is about algorithms for finding shortest paths in graphs.
        </p>
        <p>
          Path lengths allow us to talk quantitatively about the extent to which
          different vertices of a graph are separated from each other:
        </p>
        <blockquote>
          The distance between two nodes is the length of the shortest path
          between them.
        </blockquote>
        <p>
          To get a concrete feel for this notion, consider a physical
          realization of a graph that has a ball for each vertex and a piece of
          string for each edge. If you lift the ball for vertex s high enough,
          the other balls that get pulled up along with it are precisely the
          vertices reachable from s. And to find their distances from s, you
          need only measure how far below s they hang.
        </p>

        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-1.png"
            alt="A simple graph and its depth-first search tree."
            width="700"
          />
          <figcaption>
            Figure 4.1 (a) A simple graph and (b) its depth-first search tree.
          </figcaption>
        </figure>

        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-2.png"
            alt="A physical model of a graph."
            width="700"
          />
          <figcaption>Figure 4.2 A physical model of a graph.</figcaption>
        </figure>
        <p>
          In Figure 4.2 for example, vertex B is at distance 2 from S, and there
          are two shortest paths to it. When S is held up, the strings along
          each of these paths become taut. On the other hand, edge (D, E) plays
          no role in any shortest path and therefore remains slack.
        </p>
      </section>

      <section id="bfs">
        <h2>4.2 Breadth-first search</h2>
        <p>
          In Figure 4.2, the lifting of s partitions the graph into layers: s
          itself, the nodes at distance 1 from it, the nodes at distance 2 from
          it, and so on. A convenient way to compute distances from s to the
          other vertices is to proceed layer by layer. Once we have picked out
          the nodes at distance 0, 1, 2, ..., d, the ones at d + 1 are easily
          determined: they are precisely the as-yet-unseen nodes that are
          adjacent to the layer at distance d. This suggests an iterative
          algorithm in which two layers are active at any given time: some layer
          d, which has been fully identified, and d + 1, which is being
          discovered by scanning the neighbors of layer d.
        </p>
        <p>
          Breadth-first search (BFS) directly implements this simple reasoning.
          Initially the queue Q consists only of s, the one node at distance 0. And
          for each subsequent distance d = 1, 2, 3, ..., there is a point in time
          at which Q contains all the nodes at distance d and nothing else. As
          these nodes are processed (ejected off the front of the queue), their
          as-yet-unseen neighbors are injected into the end of the queue.
        </p>
        <pre class="pseudocode">
            \begin{algorithm}
            \caption{Breadth-first search (BFS)}
            \begin{algorithmic}
              \Procedure{BFS}{$G, s$}
                \ForAll{$u \in V$}
                  \State $dist(u) \gets \infty$
                \EndFor
                \State $dist(s) \gets 0$
                \State $Q \gets [s]$ \Comment{A queue containing just s}
                \While{$Q$ is not empty}
                  \State $u \gets \text{eject}(Q)$
                  \ForAll{edge $(u, v) \in E$}
                    \If{$dist(v) = \infty$}
                      \State $\text{inject}(Q, v)$
                      \State $dist(v) \gets dist(u) + 1$
                    \EndIf
                  \EndFor
                \EndWhile
              \EndProcedure
            \end{algorithmic}
            \end{algorithm}
          </pre>
        <p>
          Let's try out this algorithm on our earlier example (Figure 4.1) to
          confirm that it does the right thing. If S is the starting point and
          the nodes are ordered alphabetically, they get visited in the
          sequence shown in Figure 4.4. The breadth-first search tree, on the
          right, contains the edges through which each node is initially
          discovered. Unlike the DFS tree we saw earlier, it has the property
          that all its paths from S are the shortest possible. It is therefore a
          shortest-path tree.
        </p>

        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-4.png"
            alt="The result of breadth-first search on the graph of Figure 4.1."
            width="700"
          />
          <figcaption>
            Figure 4.4 The result of breadth-first search on the graph of Figure
            4.1.
          </figcaption>
        </figure>

        <h3>Correctness and efficiency</h3>
        <p>
          We have developed the basic intuition behind breadth-first search. In
          order to check that the algorithm works correctly, we need to make
          sure that it faithfully executes this intuition. What we expect,
          precisely, is that:
        </p>
        <blockquote>
          For each $d = 0, 1, 2, \dots$, there is a moment at which (1) all
          nodes at distance $\le d$ from s have their distances correctly set;
          (2) all other nodes have their distances set to $\infty$; and (3) the
          queue contains exactly the nodes at distance $d$.
        </blockquote>
        <p>
          This has been phrased with an inductive argument in mind. We have
          already discussed both the base case and the inductive step.
        </p>
        <p>
          The overall running time of this algorithm is linear,
          $O(|V| + |E|)$, for exactly the same reasons as depth-first search.
          Each vertex is put on the queue exactly once, when it is first
          encountered, so there are $O(|V|)$ queue operations. The rest of the
          work is done in the algorithm's innermost loop. Over the course of
          execution, this loop looks at each edge once (in directed graphs) or
          twice (in undirected graphs), and therefore takes $O(|E|)$ time.
        </p>
        <p>
          Now that we have both BFS and DFS before us: how do their exploration
          styles compare? Depth-first search makes deep incursions into a graph,
          retreating only when it runs out of new nodes to visit. Breadth-first
          search makes sure to visit vertices in increasing order of their distance
          from the starting point. This is a broader, shallower search, rather
          like the propagation of a wave upon water.
        </p>
        <p>
          Also notice one stylistic difference from DFS: since we are only
          interested in distances from s, we do not restart the search in other
          connected components. Nodes not reachable from s are simply ignored.
        </p>
      </section>

      <section id="edge-lengths">
        <h2>4.3 Lengths on edges</h2>
        <p>
          Breadth-first search treats all edges as having the same length. This
          is rarely true in applications where shortest paths are to be found.
          For instance, suppose you are driving from San Francisco to Las Vegas.
          Picking the right combination of highways is a shortest-path problem
          in which the length of each edge (each stretch of highway) is important.
          For the remainder of this chapter, we will deal with this more general
          scenario, annotating every edge $e \in E$ with a length $l_e$. If
          $e = (u, v)$, we will sometimes also write $l(u,v)$ or $l_{uv}$.
        </p>
        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-5.png"
            alt="A map of cities and highways with distances, illustrating that edge lengths often matter."
            width="700"
          />
          <figcaption>Figure 4.5 Edge lengths often matter.</figcaption>
        </figure>
        <p>
          These $l_e$'s do not have to correspond to physical lengths. They
          could denote time, cost, or any other quantity that we would like
          to conserve. In fact, there are cases in which we need to use negative
          lengths, which we will discuss later.
        </p>
      </section>

      <section id="dijkstras-algorithm">
        <h2>4.4 Dijkstra's algorithm</h2>
        <h3>4.4.1 An adaptation of breadth-first search</h3>
        <p>
          BFS finds shortest paths in any graph whose edges have unit length.
          Can we adapt it to a more general graph $G = (V,E)$ whose edge
          lengths $l_e$ are positive integers? A simple trick is to convert G
          into a graph G' that BFS can handle: break long edges into
          unit-length pieces by introducing "dummy" nodes.
        </p>
        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-6.png"
            alt="Breaking edges into unit-length pieces by adding dummy nodes."
            width="700"
          />
          <figcaption>
            Figure 4.6 Breaking edges into unit-length pieces.
          </figcaption>
        </figure>
        <p>
          However, this can be very inefficient if edge lengths are large. A
          better way is to simulate this process using a **priority queue**. This
          leads to Dijkstra's algorithm.
        </p>
        <pre class="pseudocode">
            \begin{algorithm}
            \caption{Dijkstra's Shortest-Path Algorithm}
            \begin{algorithmic}
              \Procedure{Dijkstra}{$G, l, s$}
                \ForAll{$u \in V$}
                  \State $dist(u) \gets \infty$
                  \State $prev(u) \gets \text{nil}$
                \EndFor
                \State $dist(s) \gets 0$
                \State $H \gets \text{makequeue}(V)$ \Comment{Using dist-values as keys}
                \While{$H$ is not empty}
                  \State $u \gets \text{deletemin}(H)$
                  \ForAll{edge $(u, v) \in E$}
                    \If{$dist(v) > dist(u) + l(u, v)$}
                      \State $dist(v) \gets dist(u) + l(u, v)$
                      \State $prev(v) \gets u$
                      \State $\text{decreasekey}(H, v)$
                    \EndIf
                  \EndFor
                \EndWhile
              \EndProcedure
            \end{algorithmic}
            \end{algorithm}
          </pre>
          <p>
            In the code, `dist(u)` stores the current best estimate of the
            shortest path to node `u`, and `prev(u)` stores the predecessor on that
            path. The priority queue `H` stores vertices, prioritized by their
            `dist` value. A full example of the algorithm's operation is shown in
            Figure 4.9.
          </p>

        <figure>
          <img
            src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-9.png"
            alt="A complete run of Dijkstra's algorithm."
            width="700"
          />
          <figcaption>
            Figure 4.9 A complete run of Dijkstra's algorithm, with node A as
            the starting point. Also shown are the associated dist values and
            the final shortest-path tree.
          </figcaption>
        </figure>

        <h3>4.4.2 An alternative derivation</h3>
        <p>
          An alternative view of Dijkstra's algorithm is that it grows a region of "known" vertices `R`, to which shortest paths have been found. In each step, it adds the node `v` outside of `R` that is closest to the start node `s`. The path to `v` must come from a node `u` already in `R`, so the algorithm finds the node `v` that minimizes $dist(u) + l(u,v)$ over all $u \in R$.
        </p>

        <h3>4.4.3 Running time</h3>
        <p>The running time of Dijkstra's algorithm is dominated by the priority queue operations. With $|V|$ vertices and $|E|$ edges, there are $|V|$ `deletemin` operations and up to $|E|$ `decreasekey` operations. The total time depends on the heap implementation:</p>
        
        <table>
            <thead>
                <tr>
                    <th>Implementation</th>
                    <th>Total Running Time</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Array</td>
                    <td>$O(|V|^2)$</td>
                </tr>
                <tr>
                    <td>Binary heap</td>
                    <td>$O((|V| + |E|) \log |V|)$</td>
                </tr>
                <tr>
                    <td>Fibonacci heap</td>
                    <td>$O(|V| \log |V| + |E|)$</td>
                </tr>
            </tbody>
        </table>
      </section>

      <section id="negative-edges">
        <h2>4.6 Shortest paths in the presence of negative edges</h2>
        <p>
            Dijkstra's algorithm fails if there are negative edge lengths. The core assumption that the closest node outside the "known" region is the next to be finalized is no longer true.
        </p>
        <figure>
            <img
              src="../../../assets/images/algorithms/chpt_4_imgs/figure-4-12.png"
              alt="Graph with a negative edge where Dijkstra's algorithm fails."
              width="500"
            />
            <figcaption>
              Figure 4.12 Dijkstra's algorithm will not work if there are negative edges.
            </figcaption>
        </figure>
        <p>For graphs with negative edges (but no negative cycles), we can use the **Bellman-Ford algorithm**. It works by relaxing all edges repeatedly. Since a shortest path can have at most $|V|-1$ edges, relaxing all $|E|$ edges for $|V|-1$ rounds guarantees finding the shortest path.</p>
        
        <pre class="pseudocode">
            \begin{algorithm}
            \caption{The Bellman-Ford Algorithm}
            \begin{algorithmic}
              \Procedure{Bellman-Ford}{$G, l, s$}
                \ForAll{$u \in V$}
                  \State $dist(u) \gets \infty$
                  \State $prev(u) \gets \text{nil}$
                \EndFor
                \State $dist(s) \gets 0$
                \For{$i \gets 1$ to $|V|-1$}
                  \ForAll{edge $(u,v) \in E$}
                    \If{$dist(v) > dist(u) + l(u,v)$}
                        \State $dist(v) \gets dist(u) + l(u,v)$
                        \State $prev(v) \gets u$
                    \EndIf
                  \EndFor
                \EndFor
              \EndProcedure
            \end{algorithmic}
            \end{algorithm}
          </pre>
          
        <h3>4.6.2 Negative cycles</h3>
        <p>
            The Bellman-Ford algorithm can also detect negative cycles. If, after $|V|-1$ rounds of relaxation, an additional round still manages to decrease any `dist` value, it means a negative cycle reachable from `s` exists.
        </p>
      </section>

      <section id="dags">
        <h2>4.7 Shortest paths in dags</h2>
        <p>
            For **Directed Acyclic Graphs (DAGs)**, we can find shortest paths in linear time, even with negative edges. The key is to process vertices in a **topologically sorted** order. When we process a vertex `u`, we are guaranteed to have already found the shortest paths to all vertices that can precede `u`.
        </p>
        <pre class="pseudocode">
            \begin{algorithm}
            \caption{Shortest Paths in a DAG}
            \begin{algorithmic}
              \Procedure{DAG-Shortest-Paths}{$G, l, s$}
                \State Topologically sort the vertices of G
                \ForAll{$u \in V$}
                  \State $dist(u) \gets \infty$
                  \State $prev(u) \gets \text{nil}$
                \EndFor
                \State $dist(s) \gets 0$
                \ForAll{each vertex $u$, in topological order}
                  \ForAll{edge $(u, v) \in E$}
                    \If{$dist(v) > dist(u) + l(u,v)$}
                        \State $dist(v) \gets dist(u) + l(u,v)$
                        \State $prev(v) \gets u$
                    \EndIf
                  \EndFor
                \EndFor
              \EndProcedure
            \end{algorithmic}
            \end{algorithm}
          </pre>
        <p>This algorithm runs in $O(|V|+|E|)$ time, dominated by the topological sort.</p>
      </section>

      <section id="comments">
        <script
          src="https://utteranc.es/client.js"
          repo="COD1995/ml-meta"
          issue-term="pathname"
          label="comment"
          theme="github-light"
          crossorigin="anonymous"
          async
        ></script>
      </section>

      <footer>
        <p>
          ¬© 2025 Kristopher Kodweis ‚Ä¢
          <a
            href="https://github.com/COD1995/ml-meta"
            target="_blank"
            rel="noopener"
          >
            View on GitHub
          </a>
        </p>
      </footer>
    </div>

    <script type="module" src="../../../assets/js/main.js"></script>
    <script type="module" src="../../../assets/js/chapter-page.js"></script>

    <script src="book-data.js"></script>

    <script type="module" src="../../../assets/js/build-side-nav.js"></script>
  </body>
</html>
