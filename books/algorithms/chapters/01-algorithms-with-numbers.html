<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chapter 0: Prologue</title>

    <!-- Global styles -->
    <link rel="stylesheet" href="../../../assets/css/base.css" />
    <link rel="stylesheet" href="../../../assets/css/inline-styles.css" />
    <link rel="stylesheet" href="../../../assets/css/chapters.css" />

    <!-- Library styles -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css"
    />

    <!-- MathJax global config (must come BEFORE MathJax) -->
    <script src="../../../assets/js/mathjax-config.js"></script>

    <!-- Library scripts (deferred) -->
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js"
    ></script>
    <script
      defer
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.8.0/dist/highlightjs-line-numbers.min.js"
    ></script>
  </head>

  <body>
    <!-- Reading Progress Indicator -->
    <div id="reading-progress">
      <div id="reading-progress-bar"></div>
    </div>
    
    <nav class="side-nav">
      <div class="side-nav-controls">
        <button
          id="homeBtn"
          class="btn-toggle"
          aria-label="Home"
          onclick="location.href='../../../index.html'"
        >
          üè†
        </button>
        <span class="nav-divider"></span>
        <button
          id="themeToggle"
          class="btn-toggle"
          aria-label="Toggle dark mode"
        >
          üåì
        </button>
      </div>

      <hr class="side-nav-divider" />

      <!-- everything below is built by build-side-nav.js -->
      <div id="bookNav"></div>

      <hr class="side-nav-divider" />

      <!-- Buy Me a Coffee Banner -->
      <div class="coffee-banner">
        <a
          href="https://buymeacoffee.com/guoj1995"
          id="coffeeButton"
          target="_blank"
          rel="noopener noreferrer"
          aria-label="Support ML-Meta on Buy Me a Coffee"
        >
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M20 3H4V5H20V3Z" fill="currentColor"/>
            <path d="M20 7H4C2.9 7 2 7.9 2 9V17C2 18.1 2.9 19 4 19H10C11.1 19 12 18.1 12 17V16H16C18.2 16 20 14.2 20 12V9C20 7.9 19.1 7 18 7H20Z" fill="currentColor"/>
          </svg>
          <span>Support Us</span>
        </a>
      </div>

      <!-- Slack banner (unchanged) -->
      <div class="slack-banner">
        <a
          href="https://join.slack.com/t/mlmetacommunity/shared_invite/zt-38mj0hx5v-8GyxvZ7lanC9HbywfUOwJw"
          id="slackButton"
          target="_blank"
          rel="noopener"
          aria-label="Join our Slack Community"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 122.8 122.8"
            fill="#fff"
            style="width: 1.5em; height: 1.5em; vertical-align: middle"
          >
            <path d="M30.3 78.6c0 5-4 9-9 9s-9-4-9-9 4-9 9-9h9v9z" />
            <path
              d="M34.8 78.6c0-5 4-9 9-9s9 4 9 9v22.5c0 5-4 9-9 9s-9-4-9-9V78.6z"
            />
            <path d="M44 30.3c-5 0-9-4-9-9s4-9 9-9 9 4 9 9v9H44z" />
            <path
              d="M44 34.8c5 0 9 4 9 9s-4 9-9 9H21.5c-5 0-9-4-9-9s4-9 9-9H44z"
            />
            <path d="M92.5 44c0-5 4-9 9-9s9 4 9 9-4 9-9 9h-9V44z" />
            <path
              d="M88 44c0 5-4 9-9 9s-9-4-9-9V21.5c0-5 4-9 9-9s9 4 9 9V44z"
            />
            <path d="M78.8 92.5c5 0 9 4 9 9s-4 9-9 9-9-4-9-9v-9h9z" />
            <path
              d="M78.8 88c-5 0-9-4-9-9s4-9 9-9h22.5c5 0 9 4 9 9s-4 9-9 9H78.8z"
            />
          </svg>
          <span style="margin-left: 0.5em; vertical-align: middle"
            >Join our Slack</span
          >
        </a>
      </div>
    </nav>

    <div class="container content">
      <h1>Chapter¬†1:Algorithms with numbers</h1>
      <section id="factoring-primality">
        <blockquote>
          One of the main themes of this chapter is the dramatic contrast between two ancient problems that at first seem very similar:
        </blockquote>
        
        <ul>
          <li><strong>Factoring:</strong> Given a number <code>N</code>, express it as a product of its prime factors.</li>
          <li><strong>Primality:</strong> Given a number <code>N</code>, determine whether it is a prime.</li>
        </ul>
        
        <p>
          This introduction highlights two foundational number‚Äêtheoretic tasks‚Äîbreaking a composite number into primes versus simply checking if it's prime‚Äîsetting up the surprising gap in their computational difficulty.
        </p>

        <blockquote>
          Factoring is hard. Despite centuries of effort by some of the world's smartest mathematicians and computer scientists, the fastest methods for factoring a number <code>N</code> take time exponential in the number of bits of <code>N</code>.
        </blockquote>
        
        <p>
              This paragraph emphasizes that, to date, no algorithm faster than
              exponential time is known for factoring large integers‚Äîmaking it a
              famously difficult computational challenge.
            </p>

        <blockquote>
          <em >On the other hand, we shall soon see that we can efficiently test whether <code>N</code> is prime! And (it gets even more interesting) this strange disparity between the two intimately related problems, one very hard and the other very easy, lies at the heart of the technology that enables secure communication in today‚Äôs global information environment.</em >
        </blockquote>
        
        <p>
              Here the author foreshadows that primality testing admits a
              polynomial‚Äêtime solution, and that the gap between these two tasks
              underpins public‚Äêkey cryptography and modern secure
              communications.
            </p>

        <blockquote>
          <em >En route to these insights, we need to develop algorithms for a variety of computational tasks involving numbers. We begin with basic arithmetic, an especially appropriate starting point because, as we know, the word algorithms originally applied only to methods for these problems.</em >
        </blockquote>
        
        <p>
              This closing sentence explains that to understand factoring vs.
              primality, we‚Äôll first build up efficient arithmetic
              routines‚Äîrecalling that ‚Äúalgorithm‚Äù itself once referred only to
              numerical methods.
            </p>
      </section>

      <section id="basic-arithmetic">
        <h2>1.1 Basic arithmetic</h2>

        <section id="addition">
          <h3>1.1.1 Addition</h3>

          <blockquote>
          <em >We were so young when we learned the standard technique for addition that we would scarcely have thought to ask why it works. But let's go back now and take a closer look.</em >
        </blockquote>
        
        <p>
                This introduction reminds us that addition, though second
                nature, has a precise underlying rationale‚Äîone we‚Äôll now examine
                step by step.
              </p>

          <blockquote>
          <em >It is a basic property of decimal numbers that <strong >The sum of any three single-digit numbers is at most two digits long.</strong > Quick check: the sum is at most $9+9+9=27$, two digits long. In fact, this rule holds not just in decimal but in any base $b\ge2$ (Exercise 1.1). In binary, for instance, the maximum possible sum of three single-bit numbers is 3, which is a 2-bit number.</em >
        </blockquote>
        
        <p>
                Because adding three digits can never exceed the base‚Äôs square,
                each digit‚Äêwise sum stays within two digits. This fact
                generalizes across bases and underpins the carry mechanism.
              </p>

          <blockquote>
          <em >This simple rule gives us a way to add two numbers in any base: align their right-hand ends, and then perform a single right-to-left pass in which the sum is computed digit by digit, maintaining the overflow as a carry. Since we know each individual sum is a two-digit number, the carry is always a single digit, and so at any given step, three single-digit numbers are added. Here's an example showing the addition <code>53+35</code> in binary.</em >
        </blockquote>
        
        <p>
                This describes the classic ‚Äúdigit-by-digit plus carry‚Äù
                algorithm: add corresponding digits plus the incoming carry,
                write down the least significant result, and carry the rest to
                the next column.
              </p>

          <blockquote>
          <figure> <img src="../../../assets/images/algorithms/chpt_1_imgs/addition.png" alt="Binary addition of 53 and 35 with carries" width="700" /> <figcaption> Figure 1.1: Binary addition of 53 and 35, illustrating carry propagation. </figcaption> </figure>
        </blockquote>
        
        <p>
                This ASCII illustration shows each column‚Äôs sum and carry
                propagation when adding <code>110101</code> (53) and
                <code>100011</code> (35), yielding <code>1011000</code> (88).
              </p>

          <blockquote>
          <em >Ordinarily we would spell out the algorithm in pseudocode, but in this case it is so familiar that we do not repeat it. Instead we move straight to analyzing its efficiency.</em >
        </blockquote>
        
        <p>
                Since the addition routine is universally known, we skip its
                formal specification and focus on quantifying its runtime.
              </p>

          <blockquote>
          <em >Given two binary numbers <code>x</code> and <code>y</code>, how long does our algorithm take to add them? This is the kind of question we shall persistently be asking throughout this book. We want the answer expressed as a function of the size of the input: the number of bits of <code>x</code> and <code>y</code>, the number of keystrokes needed to type them in.</em >
        </blockquote>
        
        <p>
                Here we introduce the key idea of input‚Äêsize analysis: runtime
                expressed in terms of the number of bits in the operands.
              </p>

          <blockquote>
          <em >Suppose <code>x</code> and <code>y</code> are each <code>n</code> bits long; in this chapter we will consistently use the letter <code>n</code> for the sizes of numbers. Then the sum of <code>x</code> and <code>y</code> is <code>n+1</code> bits at most, and each individual bit of this sum gets computed in a fixed amount of time. The total running time for the addition algorithm is therefore of the form <code>c<sub>0</sub> + c<sub>1</sub>n</code>, where <code>c<sub>0</sub></code> and <code>c<sub>1</sub></code> are some constants; in other words, it is linear. Instead of worrying about the precise values of <code>c<sub>0</sub></code> and <code>c<sub>1</sub></code >, we will focus on the big picture and denote the running time as <code>O(n)</code>.</em >
        </blockquote>
        
        <p>
                Since each of the <code>n+1</code> digit‚Äêcomputations takes
                constant time, the total cost grows proportionally to
                <code>n</code>, yielding an <code>O(n)</code> algorithm.
              </p>

          <blockquote>
          <em >Now that we have a working algorithm whose running time we know, our thoughts wander inevitably to the question of whether there is something even better. Is there a faster algorithm? (This is another persistent question.) For addition, the answer is easy: in order to add two <code>n</code>-bit numbers we must at least read them and write down the answer, and even that requires <code>n</code> operations. So the addition algorithm is optimal, up to multiplicative constants!</em >
        </blockquote>
        
        <p>
                Because any algorithm must examine every input bit and output
                bit, no method can beat <code>Œò(n)</code> time apart from
                constant‚Äêfactor improvements‚Äîso our linear‚Äêtime addition is
                asymptotically optimal.
              </p>

          <blockquote>
          <em >Some readers may be confused at this point: Why <code>O(n)</code> operations? Isn't binary addition something that computers today perform by just one instruction? There are two answers. First, it is certainly true that in a single instruction we can add integers whose size in bits is within the word length of today's computers‚Äî32 perhaps. But, as will become apparent later in this chapter, it is often useful and necessary to handle numbers much larger than this, perhaps several thousand bits long. Adding and multiplying such large numbers on real computers is very much like performing the operations bit by bit. Second, when we want to understand algorithms, it makes sense to study even the basic algorithms that are encoded in the hardware of today's computers. In doing so, we shall focus on the bit complexity of the algorithm, the number of elementary operations on individual bits‚Äîbecause this accounting reflects the amount of hardware, transistors and wires, necessary for implementing the algorithm.</em >
        </blockquote>
        
        <p>
                This clarification distinguishes between machine‚Äêword arithmetic
                (constant‚Äêtime on fixed‚Äêwidth registers) and arbitrary‚Äêprecision
                arithmetic, where cost truly scales with bit length‚Äîmotivating
                our focus on bit‚Äêlevel operations for algorithmic insight.
              </p>
        </section>
      </section>

      <section id="comments">
        <script
          src="https://utteranc.es/client.js"
          repo="COD1995/ml-meta"
          issue-term="pathname"
          label="comment"
          theme="github-light"
          crossorigin="anonymous"
          async
        ></script>
      </section>

      <footer>
        <p>
          ¬©¬†2025¬†Bob¬†Guo¬†‚Ä¢¬†
          <a
            href="https://github.com/COD1995/ml-meta"
            target="_blank"
            rel="noopener"
          >
            View¬†on¬†GitHub
          </a>
        </p>
      </footer>
    </div>
    <script type="module" src="../../../assets/js/main.js"></script>
    <script type="module" src="../../../assets/js/chapter-page.js"></script>
    <!-- 1Ô∏è‚É£ auto‚Äëgenerated by the build script (local to this folder) -->
    <script src="book-data.js"></script>

    <!-- 2Ô∏è‚É£ builds the sidebar & mini‚ÄëTOC in the browser -->
    <script type="module" src="../../../assets/js/build-side-nav.js"></script>
  </body>
</html>
